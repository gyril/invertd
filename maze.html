<!DOCTYPE html>
<meta charset="utf-8">

  <head>
    <title>Invertd</title>
    <style type="text/css">
    #board {
      box-shadow: 0 0 0 1px black;
      position: absolute;
      top: 50px;
      left: 50px;
    }

    #canvas, #sprites {
      position: absolute;
      top: 50px;
      left: 50px;
    }

    #sprites {
      pointer-events: none;
    }

    </style>
    <script id="worker" type="javascript/worker">
      // This script won't be parsed by JS engines because its type is javascript/worker.
      var _tick

      self.onmessage = function(e) {
        if (e.data.func == 'stop') {
          self.clearTimeout(_tick)
          return
        }

        _tick = self.setTimeout(function() {
          self.postMessage({func: e.data.func, arg: e.data.arg})
        }, e.data.interval)
      }
    </script>
    <script src="./astar.js"></script>
  </head>
  <body>
    <canvas id="board">
    </canvas>
    <canvas id="canvas">
    </canvas>
    <canvas id="sprites">
    </canvas>
    <div id="timer"></div>
    <button onclick="init()">New maze</button>
    <button onclick="start()">Retry this maze</button>
    <script type="text/javascript">  
      var blob = new Blob([
        document.querySelector('#worker').textContent
      ], { type: "text/javascript" })

      var worker = new Worker(window.URL.createObjectURL(blob))
      worker.onmessage = function(e) {
        window[e.data.func](e.data.arg)
      }
      
      var board = document.getElementById('board')
        , canvas = document.getElementById('canvas')
        , sprites = document.getElementById('sprites')
        , boardContext = board.getContext('2d')
        , canvasContext = canvas.getContext('2d')
        , spritesContext = sprites.getContext('2d')
        , cellSize = 24
        , drag = false
        , mousedown = false

      var sizeString = '20x20'
        , gridWidth = parseInt(sizeString.split('x')[0])
        , gridHeight = parseInt(sizeString.split('x')[1])
        , width = gridWidth * cellSize
        , height = gridHeight * cellSize
        , grid
        , startTime
        , buildTime
        , timer

      board.width = width
      board.height = height
      board.style.width = width + 'px'
      board.style.height = height + 'px'
      canvas.width = width
      canvas.height = height
      canvas.style.width = width + 'px'
      canvas.style.height = height + 'px'
      sprites.width = width
      sprites.height = height
      sprites.style.width = width + 'px'
      sprites.style.height = height + 'px'

      var startTile = {
          x: 0,
          y: Math.round((gridHeight-1)/2)
        }
        , endTile = {
          x: gridWidth-1,
          y: Math.round((gridHeight-1)/2)
        }
        , buildTimer = 30
        , walls
        , path
        , units
        , effects

      init()
      
      function click (e) {
        placeWall(e)
      }

      function returnCell (point) {
        return {x: Math.floor(point.x/cellSize), y: Math.floor(point.y/cellSize)}
      }

      function returnCells (point, squareSize) {
        if (squareSize == 1)
          return returnCell(point)

        if (squareSize == 2) {
          var cells = []
            , originCell = returnCell(point)
            , quadX = originCell.x == Math.round(point.x/cellSize) ? -1 : 1
            , quadY = originCell.y == Math.round(point.y/cellSize) ? -1 : 1

          cells.push(originCell)
          cells.push({x: originCell.x + quadX, y: originCell.y})
          cells.push({x: originCell.x, y: originCell.y + quadY})
          cells.push({x: originCell.x + quadX, y: originCell.y + quadY})

          return cells
        }

      }

      function init () {
        grid = []
        walls = []
        units = []
        effects = []
        worker.postMessage({func: 'stop'})

        for (var i = 0; i < gridWidth; i++) {
          grid.push([])
          for (var j = 0; j < gridHeight; j++)
            grid[i].push(new BlankCell())
        }

        drawCells()

        generateRandomWalls(20, 2)

        path = astarPath()
        drawCanvas()

        new Unit(startTile, 0)

        canvas.addEventListener('click', click, false)
        buildTime = new Date()
        
        worker.postMessage({func: 'buildTick', arg: buildTime, interval: 1000/60})
      }

      function buildTick (lastDate) {
        var now = new Date()
          , elapsed = (now - buildTime) / 1000

        document.getElementById('timer').textContent = Math.round((buildTimer - elapsed) * 100) / 100

        if (elapsed > buildTimer) {
          start(now)
          document.getElementById('timer').textContent = 'Go!'
        } else {
          worker.postMessage({func: 'buildTick', arg: now, interval: 1000/60})
        }
      }

      function start () {
        worker.postMessage({func: 'stop'})

        canvas.removeEventListener('click', click, false)

        if (units.length == 0)
          new Unit(startTile, 0)

        units[0].target = getCenter(path[0])
        units[0].direction = getDirection(units[0], units[0].target)

        startTime = new Date()
        timer = 0
        worker.postMessage({func: 'tick', arg: startTime, interval: 1000/60})
      }

      function tick (lastDate) {
        var now = new Date()
          , delta = new Date(now - lastDate).getTime() / 1000

        updateTimer(now)

        updateUnits(delta)
        updateEffects(now)
        fireTowers(now)

        drawSprites()
        
        if (units.length > 0) {
          worker.postMessage({func: 'tick', arg: now, interval: 1000/60})
        } else {
          window.alert('Your score: ' + timer)
          canvas.addEventListener('click', click, false)
        }
      }

      function drawCells () {
        for (var i=1; i < gridWidth; i++) {
          boardContext.beginPath()
          boardContext.moveTo(i * cellSize, 0)
          boardContext.lineTo(i * cellSize, height)
          boardContext.strokeStyle = '#fafafa'
          boardContext.stroke()
        }

        for (var i=1; i < gridHeight; i++) {
          boardContext.beginPath()
          boardContext.moveTo(0, i * cellSize)
          boardContext.lineTo(width, i * cellSize)
          boardContext.stroke()
        }
      }

      function drawCanvas () {
        canvasContext.clearRect(0, 0, canvas.width, canvas.height)
        drawWalls()
        drawPath()
        drawSpecialTiles()
      }

      function drawWalls () {
        for (var i = 0; i < walls.length; i++) {
          var wall = walls[i]
          
          canvasContext.beginPath()
          for (var j = 0; j < wall.cells.length; j++) {
            canvasContext.rect(wall.cells[j].x * cellSize, wall.cells[j].y * cellSize, cellSize, cellSize)
            canvasContext.fillStyle = wall.color
            canvasContext.fill()
          }
        }
      }

      function drawPath () {
        for (var i = 0; i < path.length; i++) {
          var pathpoint = path[i]
          
          canvasContext.beginPath()
          canvasContext.rect(pathpoint.x * cellSize, pathpoint.y * cellSize, cellSize, cellSize)
          canvasContext.fillStyle = 'transparent'
          canvasContext.fill()
        }
      }

      function drawSpecialTiles () {
        canvasContext.beginPath()
        canvasContext.rect(startTile.x * cellSize, startTile.y * cellSize, cellSize, cellSize)
        canvasContext.fillStyle = 'pink'
        canvasContext.fill()
        canvasContext.rect(endTile.x * cellSize, endTile.y * cellSize, cellSize, cellSize)
        canvasContext.fillStyle = 'pink'
        canvasContext.fill()
      }

      function drawSprites () {
        spritesContext.clearRect(0, 0, sprites.width, sprites.height)
        drawUnits()
        drawEffects()
      }

      function drawUnits () {
        for (var i = 0; i < units.length; i++) {
          var unit = units[i]
          
          spritesContext.beginPath()
          spritesContext.arc(unit.x, unit.y, unit.size, 0, 2 * Math.PI, false)
          spritesContext.fillStyle = unit.color
          spritesContext.fill()
        }       
      }

      function drawEffects () {
        for (var i = 0; i < effects.length; i++) {
          var effect = effects[i]
          
          spritesContext.beginPath()
          spritesContext.arc(effect.x, effect.y, effect.size, 0, 2 * Math.PI, false)
          spritesContext.fillStyle = effect.color
          spritesContext.save()
          spritesContext.globalAlpha = effect.alpha
          spritesContext.fill()
          spritesContext.restore()
        }       
      }

      function updateTimer (now) {
        timer = Math.round(((now - startTime) / 1000) * 100) / 100

        document.getElementById('timer').textContent = timer
      }

      function updateUnits (delta) {
        for (var i = 0; i < units.length; i++) {
          var unit = units[i]
          if (Math.abs(getDirection(unit, unit.target) - unit.direction) > 3 && unit.node < path.length) {
            unit.node++
            if (unit.node > path.length - 1) {
              unit.win()
            } else {
              unit.target = getCenter(path[unit.node])
              unit.direction = getDirection(unit, unit.target)
            }
          }
          unit.x += Math.cos(unit.direction) * unit.velocity * delta
          unit.y += Math.sin(unit.direction) * unit.velocity * delta
        }
      }

      function updateEffects (now) {
        for (var i = effects.length - 1; i >= 0; i--) {
          var effect = effects[i]

          if (now - effect.started > effect.duration)
            effect.remove()
          else {
            effect.alpha = Easings[effect.easeout](1 - (now - effect.started) / effect.duration)
          }
        };
      }

      function fireTowers (now) {
        for (var i = 0; i < walls.length; i++) {
          var tower = walls[i]

          // Can break out of the loop because it towers are at the beginning of `towers` Array
          if (tower.constructor.name != 'Tower')
            break

          if (tower.lastFired + tower.reloadTime <= now.getTime()) {
            for (var j = 0; j < units.length; j++) {
              if (getDistanceBetween(units[j], tower.center) < tower.range * cellSize && tower.lastFired != now.getTime()) {
                tower.lastFired = now.getTime()
                tower.fire(units[j])
              }
            }
          }
        }
      }

      function placeWall (e) {
        var cell = returnCell({x: e.offsetX, y: e.offsetY})

        if (grid[cell.x][cell.y].constructor.name == 'Wall') {
          grid[cell.x][cell.y].remove()
        }

        else {
          var cells = returnCells({x: e.offsetX, y: e.offsetY}, 2)

          if (!areBlanks(cells) || isSpecialTile(cells)) {
            
          } else {
            new Wall(cells)
          }
        }
      }

      function generateRandomWalls (wallsQty, towersQty) {
        for (var i = 0; i < wallsQty; i++) {
          var e = { 
            x: Math.floor(Math.random()*gridWidth*cellSize),
            y: Math.floor(Math.random()*gridHeight*cellSize)
          }

          var cells = returnCells(e, 2)

          while(!areBlanks(cells) || isSpecialTile(cells)) {
            e.x = Math.floor(Math.random()*gridWidth*cellSize)
            e.y = Math.floor(Math.random()*gridHeight*cellSize)

            cells = returnCells(e, 2)
          } 

          if (i < towersQty)
            new Tower(cells, true)
          else new Wall(cells, true)
        }
      }

      function areBlanks (cells) {
        var rep = true
        for (var i = 0; i < cells.length; i++)
          if (cells[i].x < 0 || cells[i].x > gridWidth - 1 || cells[i].y < 0 || cells[i].y > gridHeight - 1 || grid[cells[i].x][cells[i].y].constructor.name != 'BlankCell')
            rep = false

        return rep

      }

      function isSpecialTile (cells) {
        var rep = false
        for (var i = 0; i < cells.length; i++)
          if ((cells[i].x == startTile.x && cells[i].y == startTile.y) || (cells[i].x == endTile.x && cells[i].y == endTile.y))
            rep = true

        return rep
      }

      function astarPath() {
        var graph = new Graph(graphGrid(grid), { diagonal: true })
          , start = graph.grid[startTile.x][startTile.y]
          , end = graph.grid[endTile.x][endTile.y]

        return astar.search(graph, start, end)
      }

      function graphGrid (grid) {
        var rep = []
        for (var i = 0; i < grid.length; i++) {
          rep.push([])
          for (var j = 0; j < grid[i].length; j++)
            rep[i][j] = areBlanks([{x: i, y: j}]) ? 1 : 0
        }

        return rep
      }

      function BlankCell () {

      }

      function Wall (cells, fixed) {
        this.cells = cells
        this.fixed = fixed

        this.color = this.fixed ? 'orange' : 'yellow'

        this.init = function () {
          var downRightCell = {
            x:0,
            y:0
          }

          for (var i = 0; i < cells.length; i++) {
            grid[cells[i].x][cells[i].y] = this
            downRightCell.x = cells[i].x > downRightCell.x ? cells[i].x : downRightCell.x
            downRightCell.y = cells[i].y > downRightCell.y ? cells[i].y : downRightCell.y
          }

          this.center = {
            x: downRightCell.x * cellSize,
            y: downRightCell.y * cellSize
          }

          walls.push(this)

          path = astarPath()
          if (path.length == 0)
            this.remove()
          
          drawCanvas()
        }

        this.remove = function () {
          if (this.fixed)
            return

          for (var i = 0; i < cells.length; i++)
            grid[cells[i].x][cells[i].y] = new BlankCell()

          walls.splice(walls.indexOf(this), 1)

          path = astarPath()

          drawCanvas()
        }

        this.init()
      }

      function Tower (cells, fixed) {
        Wall.apply(this, arguments)
        this.color = 'red'

        this.range = 4
        this.reloadTime = 2500
        this.lastFired = 0

        this.crippleFactor = .5
        this.crippleDuration = 2000

        this.fire = function (target) {
          effects.push(new Effect({
            type: 'circle',
            color: this.color,
            easeout: 'easeInCubic',
            center: this.center,
            size: this.range * cellSize,
            duration: this.reloadTime
          }))

          target.cripple(this.crippleFactor, this.crippleDuration)
        }
      }

      function Effect (effect) {
        this.type = effect.type
        this.color = effect.color
        this.easeout = effect.easeout
        this.x = effect.center.x
        this.y = effect.center.y
        this.size = effect.size
        this.duration = effect.duration
        this.started = new Date()
        this.alpha = 1

        this.remove = function () {
          effects.splice(effects.indexOf(this), 1)
        }
      }

      function Unit (spawnCell, nextNode) {
        this.x = getCenter(spawnCell).x
        this.y = getCenter(spawnCell).y
        this.size = 4
        this.color = 'steelblue'
        this.velocity = width/4
        this.node = nextNode
        this.target = getCenter(path[this.node])
        this.direction = getDirection(getCenter(spawnCell), this.target)

        this.init = function () {
          units.push(this)

          drawSprites()
        }

        this.cripple = function (factor, duration) {
          this.velocity *= factor
          _this = this
          window.setTimeout(function() {
            _this.velocity /= factor
          }, duration)
        }

        this.win = function () {
          units.splice(units.indexOf(this), 1)
        }

        this.init()
      }

      function getCenter (cell) {
        return {
          x: cell.x * cellSize + cellSize/2,
          y: cell.y * cellSize + cellSize/2
        }
      }

      function getDirection (point0, point1) {
        return Math.round(Math.atan2( point1.y - point0.y, point1.x - point0.x ) * 1000) / 1000
      }

      function getDistanceBetween(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2))
      }

      Easings = {
        'easeInCubic': function (x) {
          return Math.pow(x, 10)
        }
      }

    </script>
  </body>
</html>