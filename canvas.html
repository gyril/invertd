<html>
<head>
  <title>Invertd</title>
  <style type="text/css">
  #board {
    box-shadow: 0 0 0 2px black;
    position: absolute;
    top: 50px;
    left: 50px;
  }

  #canvas, #sprites {
    position: absolute;
    top: 50px;
    left: 50px;
  }

  #sprites {
    pointer-events: none;
  }

  </style>
</head>
<body>
  <button onclick="towerPlacement()">tower placement</button>
  <button onclick="originalPathing()">draw original path</button>
  <button onclick="selectArmy()">select army</button>
  <button onclick="play()">play</button>
  <button onclick="reset()">reset</button>
  <br>
  <canvas id="board">
  </canvas>
  <canvas id="canvas">
  </canvas>
  <canvas id="sprites">
  </canvas>

  

  <script type="text/javascript">  
    var board = document.getElementById('board')
      , canvas = document.getElementById('canvas')
      , sprites = document.getElementById('sprites')
      , boardContext = board.getContext('2d')
      , context = canvas.getContext('2d')
      , spritesContext = sprites.getContext('2d')
      , cellSize = 40
      , phase = 'blank'
      , drag = false
      , mousedown = false
      , currentCell = [-1, -1]
      , startTime
      , _tick

    //canvas.addEventListener('click', clickCanvas, false)
    canvas.addEventListener('mousedown', mouseDown, false)
    canvas.addEventListener('mouseup', mouseUp, false)
    canvas.addEventListener('mousemove', mouseMove, false)

    var sizeString = window.prompt('map size (WxH)')
      , gridWidth = parseInt(sizeString.split('x')[0])
      , gridHeight = parseInt(sizeString.split('x')[1])
      , width = gridWidth * cellSize
      , height = gridHeight * cellSize

    var towers = []
      , army = []
      , units = []
      , ammo = []
      , path = []
      , linePath = []
      , linePathLength = 0

    board.width = width
    board.height = height
    board.style.width = width + 'px'
    board.style.height = height + 'px'
    canvas.width = width
    canvas.height = height
    canvas.style.width = width + 'px'
    canvas.style.height = height + 'px'
    sprites.width = width
    sprites.height = height
    sprites.style.width = width + 'px'
    sprites.style.height = height + 'px'

    drawCells()

    // Inputs 

    function clickCanvas (e) {
      var cellClicked = returnCell(e)
      click(cellClicked)
    }

    function mouseDown (e) {
      mousedown = true
    }

    function mouseUp (e) {
      mousedown = false
      if (drag)
        drag = false
      else clickCanvas(e)
    }

    function mouseMove (e) {
      if (!mousedown)
        return

      drag = true

      var previousCell = currentCell
      currentCell = returnCell(e)

      if (currentCell[0] != previousCell[0] || currentCell[1] != previousCell[1]) {
        clickCanvas(e)
      }
        
    }

    function click (cell) {
      switch (phase) {
        case 'towerPlacement':
          toggleTower(cell)
          break;
        case 'originalPathing':
          togglePath(cell)
          break;
        case 'editPathing':
          break;
        default:
          break;
      }
    }

    function returnCell (e) {
      return [Math.floor(e.offsetX/cellSize), Math.floor(e.offsetY/cellSize)]
    }

    // init

    function drawCells () {
      for (var i=1; i < gridWidth; i++) {
        boardContext.beginPath()
        boardContext.moveTo(i*cellSize, 0)
        boardContext.lineTo(i*cellSize, height)
        boardContext.stroke()
      }

      for (var i=1; i < gridHeight; i++) {
        boardContext.beginPath()
        boardContext.moveTo(0, i*cellSize)
        boardContext.lineTo(width, i*cellSize)
        boardContext.stroke()
      }
    }

    function reset () {
      towers = []
      path = []

      draw()
    }

    function toggleTower (cell) {
      var _cell = cellType(cell)

      if (_cell.type == 'blank') {
        towers.push(new Tower(cell))
      } else if (_cell.type == 'tower') {
        towers.splice(_cell.index, 1)
      } else {
        // should not happen
      }

      draw()
    }

    function togglePath (cell) {
      var _cell = cellType(cell)

      if (_cell.type == 'blank') {
        path.push(new Pathpoint(cell))
      } else if (_cell.type == 'path') {
        path.splice(_cell.index, 1)
      } else {
        // clicked tower: do nothing
      }

      draw()
    }

    function cellType (cell) {
      for (var i = 0; i < towers.length; i++)
        if (towers[i].x == cell[0] && towers[i].y == cell[1])
          return {type: 'tower', index: i}

      for (var i = 0; i < path.length; i++)
        if (path[i].x == cell[0] && path[i].y == cell[1])
          return {type: 'path', index: i}

      return {type: 'blank', index: -1}
    }

    // Drawing

    function draw () {
      context.clearRect(0, 0, canvas.width, canvas.height)

      //draw path
      for (var i = 0; i < path.length; i++) {
        var pathpoint = path[i]
        context.beginPath()
        context.rect(pathpoint.x * cellSize, pathpoint.y * cellSize, cellSize, cellSize)
        context.fillStyle = pathpoint.color
        context.fill()
      }

      // draw towers
      for (var i = 0; i < towers.length; i++) {
        var tower = towers[i]

        // tower area effect
        context.beginPath()
        context.arc(getCenter(tower).x, getCenter(tower).y, tower.range * cellSize, 0, 2 * Math.PI, false)
        context.fillStyle = tower.color
        context.save()
        context.globalAlpha = 0.2
        context.fill()
        context.restore()

        // tower position
        context.beginPath()
        context.rect(tower.x * cellSize + (cellSize - tower.size) / 2, tower.y * cellSize + (cellSize - tower.size) / 2, tower.size, tower.size)
        context.fillStyle = tower.color
        context.fill()
      }
    }

    function drawUnits () {
      spritesContext.clearRect(0, 0, sprites.width, sprites.height)

      for (var i = 0; i < units.length; i++) {
        var unit = units[i]
        spritesContext.beginPath()
        spritesContext.arc(unit.coords.x, unit.coords.y, unit.size, 0, 2 * Math.PI, false)
        spritesContext.fillStyle = unit.color
        spritesContext.save()
        spritesContext.globalAlpha = 1 - unit.damage / unit.hp
        spritesContext.fill()
        spritesContext.restore()
      }

      for (var i = 0; i < ammo.length; i++) {
        var round = ammo[i]
        spritesContext.beginPath()
        spritesContext.arc(round.coords.x, round.coords.y, round.size, 0, 2 * Math.PI, false)
        spritesContext.fillStyle = round.color
        spritesContext.fill()
      }
    }

    // Tick

    function tick (prevDate) {
      if (units.length == 0)
        return

      var date = new Date(),
          delta = (new Date(date - prevDate).getTime())

      // advance units
      for (var i = 0; i < units.length; i++) {
        var unit = units[i]
        if (new Date(date - startTime).getTime()/1000 < i)
          break;

        unit.distance += unit.velocity * (delta / 1000)

        if (unit.distance >= linePathLength) {
          unit.win()
          break
        }

        unit.coords = getPositionFromDistance(Math.round(unit.distance))
      }

      // fire towers
      for (var i = 0; i < towers.length; i++) {
        var tower = towers[i]
        if (tower.lastFired + tower.reloadTime > date.getTime())
          break

        for (var j = 0; j < units.length; j++) {

          if (getDistanceBetween(units[j].coords, getCenter(tower)) < tower.range * cellSize && tower.lastFired != date.getTime()) {
            tower.lastFired = date.getTime()
            tower.fire(units[j])
          }
        }
      }

      // advance ammo
      for (var i = 0; i < ammo.length; i++) {
        var round = ammo[i]
        round.coords.x += Math.cos(round.direction) * round.velocity * (delta / 1000)
        round.coords.y += Math.sin(round.direction) * round.velocity * (delta / 1000)

        if(round.coords.x > width || round.coords.x < 0 || round.coords.y > height || round.coords.y < 0)
          round.destroy()
      }

      drawUnits()
      _tick = window.setTimeout(function() { tick(date) }, 1000/60)
    }

    function getCenter(pathpoint) {
      return {
        x: pathpoint.x * cellSize + cellSize/2,
        y: pathpoint.y * cellSize + cellSize/2
      }
    }

    // Phases

    function towerPlacement () {
      phase = 'towerPlacement'
    }

    function originalPathing () {
      phase = 'originalPathing'
    }

    function selectArmy () {
      phase = 'blank'
      var newArmy = window.prompt('Define army', JSON.stringify(army))
      army = JSON.parse(newArmy)
    }

    function play () {
      for (var i = 0; i < army.length; i++) {
        switch (army[i]) {
          case 0:
            units.push(new Kryl())
            break
          case 1:
            units.push(new Krei())
            break
          default:
            break
        }
      }

      orderPath()
      setlinePath()
      startTime = new Date()
      tick(startTime)
    }

    function orderPath() {
      for (var i = 1; i < path.length; i++) {
        var pathpoint0 = path[i]
          , k = -1

        for (var j = i; j<path.length; j++) {
          if(Math.abs(path[i-1].x - path[j].x) + Math.abs(path[i-1].y - path[j].y) == 1)
            k = j
        }

        if (k < 0) {
          alert('route non continue')
          return
        }

        path[i] = path[k]
        path[k] = pathpoint0
      }
    }

    function setlinePath () {
      var waypoints = []
      for (var i = 0; i < path.length; i++)
        waypoints.push(getCenter(path[i]))

      linePath.push(waypoints[0])

      for (var i = 1; i < waypoints.length - 1; i++)
        if (getDirection(waypoints[i+1], waypoints[i]) != getDirection(waypoints[i], waypoints[i-1])) {
          linePath.push(waypoints[i])
          linePathLength += getDistanceBetween(linePath[linePath.length-1], linePath[linePath.length-2])
        }

      linePath.push(waypoints[waypoints.length-1])
      linePathLength += getDistanceBetween(linePath[linePath.length-1], linePath[linePath.length-2])
    }

    function getDirection(pathpoint1, pathpoint0) {
      return Math.atan2( pathpoint1.y - pathpoint0.y, pathpoint1.x - pathpoint0.x )
    }

    function getPositionFromDistance(distance) {
      var d = distance
        , i = 0
        , segmentLength = getDistanceBetween(linePath[i+1], linePath[i])

      while (d > segmentLength) {
        i++
        d -= segmentLength
        segmentLength = getDistanceBetween(linePath[i+1], linePath[i])
      }

      return getPositionInSegment(linePath[i+1], linePath[i], d)
    }

    function getDistanceBetween(p1, p2) {
      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2))
    }

    function getPositionInSegment(p1, p2, d) {
      return {
        x: p2.x + d * (p1.x - p2.x ? p1.x - p2.x < 0 ? -1 : 1 : 0),
        y: p2.y + d * (p1.y - p2.y ? p1.y - p2.y < 0 ? -1 : 1 : 0)
      }
    }

    // Classes

    function Tower (cell) {
      this.x = cell[0]
      this.y = cell[1]

      this.range = 2
      this.damage = 10
      this.reloadTime = 500
      this.lastFired = 0
      this.size = 20
      this.color = 'red'

      this.fire = function (target) {
        target.damage += this.damage
        ammo.push(new Round(this, target))
        if (target.damage >= target.hp)
          target.die()
      }
    }

    function Round (tower, target) {
      this.coords = {
        x: getCenter(tower).x,
        y: getCenter(tower).y
      }

      this.velocity = 400
      this.direction = getDirection(target.coords, getCenter(tower))
      this.size = 2

      this.target = {
        x: target.coords.x,
        y: target.coords.y
      }

      this.destroy = function () {
        ammo.splice(ammo.indexOf(this), 1)
      }

      this.color = tower.color
    }

    function Pathpoint (cell) {
      this.x = cell[0]
      this.y = cell[1]

      this.color = 'yellow'
    }

    function Unit () {
      this.dead = false
      this.distance = 0
      this.damage = 0
      this.coords = {
        x: -20,
        y: 20
      }

      this.win = function () {
        units.splice(units.indexOf(this), 1)
        console.log('yeah')
      }

      this.die = function () {
        units.splice(units.indexOf(this), 1)
        console.log('argl')
      }
    }

    function Kryl () {
      Unit.apply(this, arguments)

      this._type = 'kryl'
      this.hp = 250
      this.cost = 200
      this.velocity = 30
      this.size = 5
      this.color = '#f48000'
    }

    function Krei () {
      Unit.apply(this, arguments)

      this._type = 'krei'
      this.hp = 500
      this.cost = 500
      this.velocity = 30
      this.size = 6
      this.color = '#3f83a3'
    }

    // Color manipulation

    function shadeColor(color, percent) {   
      var f=parseInt(color.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF
      return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1)
    }

    function blendColors(c0, c1, p) {
        var f=parseInt(c0.slice(1),16),t=parseInt(c1.slice(1),16),R1=f>>16,G1=f>>8&0x00FF,B1=f&0x0000FF,R2=t>>16,G2=t>>8&0x00FF,B2=t&0x0000FF
        return "#"+(0x1000000+(Math.round((R2-R1)*p)+R1)*0x10000+(Math.round((G2-G1)*p)+G1)*0x100+(Math.round((B2-B1)*p)+B1)).toString(16).slice(1)
    }

  </script>
</body>
</html>